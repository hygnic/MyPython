# User: hygnic
# Date: 2018/8/27


# 数据结构：
#     dict, set, list（str tuple）

# 常用的数据类型:
#     int、long、float、bool、str

# 赋值：
    # list1 和 list2 同时指向一个列表时
    # 在列表中添加新值时，列表中又多存储了一个新元素的地址，而列表本身的地址没有变化，
        # 所以lst1和lst2的id均没有改变并且都被添加了一个新的元素。
    # 简单的比喻一下，我们出去吃饭，lst1和lst2就像是同桌吃饭的两个人，两个人公用一张桌子，
        # 只要桌子不变，桌子上的菜发生了变化两个人是共同感受的

        # 详见： https://www.cnblogs.com/Eva-J/p/5534037.html

# 关与深浅拷贝：

    # 我们已经详细了解了变量赋值的过程。对于复杂的数据结构来说，赋值就等于完全共享了资源，
            # 一个值的改变会完全被另一个值共享。
    # 然而有的时候，我们偏偏需要将一份数据的原始内容保留一份，再去处理数据，这个时候使用赋值就不够明智了。
            # python为这种需求提供了copy模块。提供了两种主要的copy方法，一种是普通的copy，另一种是deepcopy。
                # 我们称前者是浅拷贝，后者为深拷贝。


import copy

# 浅拷贝：浅拷贝：不管多么复杂的数据结构，浅拷贝都只会copy一层。

a = [[1, 2, 3], 4, 'a']

b = a.copy()
b[0] = 0
a[1] -= 1 # 减一
print(b)       # result ：[0, 4, 'a']
print(a)       # result ：[[1, 2, 3], 3, 'a']
                    # 可以看到b[0]=0 没有影响到a


c = a.copy()
c[0][0] = 9
print(c)        # result: [[9, 2, 3], 3, 'a']
print(a)        # result: [[9, 2, 3], 3, 'a']
                    # 对于修改列表中的列表时，浅拷贝就没用了，因为他就拷贝一层

print('*'*30)

d = [[2, 4, 6, 8], 23, 43, 20]
# 深拷贝，列表的列表中元素，不变；浅拷贝，变
e = copy.deepcopy(d)
e[0][0] = 300
print(d)

print(d)
print(e)


print('\n')
k = [9, 8, 8, 0]
l = k
k[2] = 123
print(l)